// Generated by CoffeeScript 2.3.2
(function() {
  // # Ambari Configs Groups

  // Create ambari config groups [REST API v2](https://github.com/apache/ambari/blob/trunk/ambari-server/docs/api/v1)

  // * `password` (string)
  //   Ambari Administrator password.
  // * `url` (string)   
  //   Ambari External URL.
  // * `username` (string)
  //   Ambari Administrator username.
  // * `cluster_name` (string)   
  //   Name of the cluster, required
  // * `group_name` (string)   
  //   The config groups name, required
  // * `description` (string)   
  //   description associated to config group
  // * `tag` (string)   
  //   tag of the config groups, required
  //   Tha tag is wht identified uniquely on admin side the config groups
  // * `hosts` (string|array)   
  //   hosts which should belong to config group.
  // * `desired_configs` (object)   
  //   The object describing files types and properties.
  //   the key is the configuration_type, value are the properties.

  // ## Exemple

  // ```js
  // configs.groups({
  //   "username": 'ambari_admin',
  //   "password": 'ambari_secret',
  //   "url": "http://ambari.server.com",
  //   "cluster_name": 'ryba_test',
  //   "group_name": "compute_worker"
  //   "tag": "a tag"
  //   "description": "yarn high compute power"
  //   "hosts": ['worker01.metal.ryba']
  //   "desired_configs": {
  //     "type: "hdfs-site",
  //     "tag": "advances hdfs site",
  //     "properties": {
  //       "datanode.dir": "[DISK]file://data/1/hdfs"
  //       }  
  //   }
  //   }
  // }, function(err, status){
  //   console.log( err ? err.message : "Config groups CREATED/UPDATED: " + status)
  // })
  // ```

  // ## Source Code
  // This functions does a single post request with desired_configs and config_group.
  // Hosts can be empty as the config group can be uptade with a later PUT request.
  var merge, path, utils,
    indexOf = [].indexOf;

  module.exports = function(options, callback) {
    var config, do_end, do_get_config_group_item, do_post_config_group, err, error, hostname, i, k, len, name, opts, path, port, ref, ref1, status, v, value;
    if (typeof options.options === 'object') {
      options = options.options;
    }
    if (options.debug) {
      process.stdout.write("Entering config.grous.add\n");
    }
    error = null;
    status = false;
    if (options.debug == null) {
      options.debug = false;
    }
    if (options.merge == null) {
      options.merge = true;
    }
    do_end = function() {
      if (callback != null) {
        return callback(error, status);
      }
      return new Promise(function(fullfil, reject) {
        if (error != null) {
          reject(error);
        }
        return fullfil(status);
      });
    };
    try {
      if (!options.username) {
        throw Error('Required Options: username');
      }
      if (!options.password) {
        throw Error('Required Options: password');
      }
      if (!options.url) {
        throw Error('Required Options: url');
      }
      if (!options.cluster_name) {
        throw Error('Required Options: cluster_name');
      }
      if (!options.group_name) {
        throw Error('Required Options: group_name');
      }
      if (!options.tag) {
        throw Error('Required Options: tag');
      }
      if (!options.desired_configs) {
        throw Error('Required Options: desired_configs');
      }
      if (!Array.isArray(options.desired_configs)) {
        options.desired_configs = [options.desired_configs];
      }
      if (options.hosts == null) {
        options.hosts = [];
      }
      if (!Array.isArray(options.hosts)) {
        options.hosts = [options.hosts];
      }
      if (options.description == null) {
        options.description = `config group cluster: ${options.cluster_name} group ${options.group_name}`;
      }
      [hostname, port] = options.url.split("://")[1].split(':');
      if (options.sslEnabled == null) {
        options.sslEnabled = options.url.split('://')[0] === 'https';
      }
      path = `/api/v1/clusters/${options.cluster_name}`;
      opts = {
        hostname: hostname,
        port: port,
        rejectUnauthorized: false,
        headers: utils.headers(options),
        sslEnabled: options.sslEnabled
      };
      ref = options.desired_configs;
      //check desired_configs keys
      for (i = 0, len = ref.length; i < len; i++) {
        config = ref[i];
        for (k in config) {
          v = config[k];
          if (!config.type) {
            throw Error("Missing config.type");
          }
          if (!config.tag) {
            throw Error("Missing config.tag");
          }
          if (!config.properties) {
            throw Error("Missing config.properties");
          }
          ref1 = config.properties;
          for (name in ref1) {
            value = ref1[name];
            if (Array.isArray(value)) {
              config.properties[name] = value.join(',');
            }
          }
        }
      }
      // ## Get Config Group Item
      // get groupname and tag at index i to check if matches options.tag and options.group_name
      do_get_config_group_item = function(index, configs) {
        config = configs[index];
        opts['method'] = 'GET';
        opts.path = config.href;
        return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
          var do_update_config, host, j, l, len1, len2, ref2, ref3, should_update;
          try {
            if (err) {
              throw err;
            }
            response = JSON.parse(response);
            if (parseInt(statusCode) !== 200) {
              throw response.message;
            }
            if ((response.ConfigGroup.group_name === options.group_name) && (response.ConfigGroup.tag === options.tag)) {
              if (typeof this.log === "function") {
                this.log({
                  message: `Config group ${options.group_name} found via API`,
                  level: 'INFO',
                  module: 'ryba-ambari-actions/configs/groups/add'
                });
              }
              //check config groups are identical
              should_update = false;
              ref2 = response.ConfigGroup.hosts.map(function(host) {
                return host.host_name;
              });
              for (j = 0, len1 = ref2.length; j < len1; j++) {
                host = ref2[j];
                if (indexOf.call(options.hosts, host) < 0) {
                  should_update = true;
                  if (typeof this.log === "function") {
                    this.log({
                      message: `Current Config group ${options.group_name} does not contain host ${host}`,
                      level: 'INFO',
                      module: 'ryba-ambari-actions/configs/groups/add'
                    });
                  }
                }
              }
              ref3 = options.hosts;
              for (l = 0, len2 = ref3.length; l < len2; l++) {
                host = ref3[l];
                if (indexOf.call(response.ConfigGroup.hosts.map(function(host) {
                  return host.host_name;
                }), host) < 0) {
                  should_update = true;
                  if (typeof this.log === "function") {
                    this.log({
                      message: `New Config group ${options.group_name} does not contain host ${host}`,
                      level: 'INFO',
                      module: 'ryba-ambari-actions/configs/groups/add'
                    });
                  }
                }
              }
              do_update_config = function() {
                var newConfigGroup;
                opts['method'] = 'PUT';
                opts.path = `${path}/config_groups/${config.ConfigGroup.id}`;
                newConfigGroup = {
                  ConfigGroup: {
                    cluster_name: options.cluster_name,
                    group_name: options.group_name,
                    tag: options.tag,
                    description: options.description,
                    hosts: options.hosts.map(function(host) {
                      return {
                        host_name: host
                      };
                    }),
                    desired_configs: options.desired_configs
                  }
                };
                opts.content = JSON.stringify(newConfigGroup);
                if (typeof this.log === "function") {
                  this.log({
                    message: `Will update Config group ${options.group_name} with id ${config.ConfigGroup.id} via API`,
                    level: 'INFO',
                    module: 'ryba-ambari-actions/configs/groups/add'
                  });
                }
                return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
                  try {
                    if (err) {
                      throw err;
                    }
                    console.log(err, statusCode, response);
                    switch (parseInt(statusCode)) {
                      case 200:
                        if (typeof this.log === "function") {
                          this.log({
                            message: `Config group ${options.group_name} updated via API`,
                            level: 'INFO',
                            module: 'ryba-ambari-actions/configs/groups/add'
                          });
                        }
                        status = true;
                        index = index + 1;
                        if (index === configs.length) {
                          return do_end();
                        } else {
                          return do_get_config_group_item(index, configs);
                        }
                        break;
                      case 409:
                        status = false;
                        index = index + 1;
                        if (index === configs.length) {
                          return do_end();
                        } else {
                          return do_get_config_group_item(index, configs);
                        }
                        break;
                      default:
                        error = Error(response.message);
                        return do_end();
                    }
                  } catch (error1) {
                    err = error1;
                    error = err;
                    return do_end();
                  }
                });
              };
              if (should_update) {
                return do_update_config();
              }
              opts.path = response.ConfigGroup.desired_configs[0].href;
              opts['method'] = 'GET';
              if (typeof this.log === "function") {
                this.log({
                  message: `Reading current properties Config group ${options.group_name} updated via API`,
                  level: 'INFO',
                  module: 'ryba-ambari-actions/configs/groups/add'
                });
              }
              if (typeof this.log === "function") {
                this.log({
                  message: `url: ${opts.path}`,
                  level: 'INFO',
                  module: 'ryba-ambari-actions/configs/groups/add'
                });
              }
              return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
                var diff_props, len3, m, prop, ref4, ref5;
                diff_props = [];
                try {
                  if (err) {
                    throw err;
                  }
                  response = JSON.parse(response);
                  if (parseInt(statusCode) !== 200) {
                    throw response.message;
                  }
                  ref4 = response.items[0].properties;
                  for (prop in ref4) {
                    v = ref4[prop];
                    if (v !== options.desired_configs[0].properties[prop]) {
                      should_update = true;
                      diff_props.push(prop);
                    }
                  }
                  ref5 = options.desired_configs[0].properties;
                  for (prop in ref5) {
                    v = ref5[prop];
                    if (v !== response.items[0].properties[prop]) {
                      should_update = true;
                      if (diff_props.indexOf(prop) === -1) {
                        diff_props.push(prop);
                      }
                    }
                  }
                  for (m = 0, len3 = diff_props.length; m < len3; m++) {
                    prop = diff_props[m];
                    if (typeof this.log === "function") {
                      this.log({
                        message: `New Config group ${options.group_name} property ${prop} was ${response.items[0].properties[prop]} and is now ${options.desired_configs[0].properties[prop]}`,
                        level: 'INFO',
                        module: 'ryba-ambari-actions/configs/groups/add'
                      });
                    }
                  }
                  if (should_update) {
                    return do_update_config();
                  } else {
                    return do_end();
                  }
                } catch (error1) {
                  err = error1;
                  error = err;
                  return do_end();
                }
              });
            } else {
              //# check if the index is the arrya's length (meaning that allitems have been checked)
              index = index + 1;
              if (index === configs.length) {
                return do_post_config_group(); //if get the length of the array without matching, mean the config group does not exist
              } else {
                return do_get_config_group_item(index, configs);
              }
            }
          } catch (error1) {
            err = error1;
            error = err;
            return do_end();
          }
        });
      };
      do_post_config_group = function() {
        var newConfigGroup;
        opts['method'] = 'POST';
        opts.path = `${path}/config_groups`;
        newConfigGroup = {
          ConfigGroup: {
            cluster_name: options.cluster_name,
            group_name: options.group_name,
            tag: options.tag,
            description: options.description,
            hosts: options.hosts.map(function(host) {
              return {
                host_name: host
              };
            }),
            desired_configs: options.desired_configs
          }
        };
        opts.content = JSON.stringify(newConfigGroup);
        if (options.debug) {
          process.stdout.write(`config.grous.add: post configGroup ${options.group_name}\n`);
        }
        // opts.json = true
        return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
          try {
            if (err) {
              throw err;
            }
            response = JSON.parse(response);
            switch (parseInt(statusCode)) {
              case 201:
                if (options.debug) {
                  process.stdout.write(`config.grous.add: created configGroup ${options.config_name}\n`);
                }
                status = true;
                return do_end();
              case 409:
                status = false;
                return do_end();
              default:
                throw Error(response.message);
            }
          } catch (error1) {
            err = error1;
            error = err;
            return do_end();
          }
        });
      };
      opts['method'] = 'GET';
      opts.path = `${path}/config_groups`;
      return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
        try {
          if (err) {
            throw err;
          }
          response = JSON.parse(response);
          if (parseInt(statusCode) !== 200) {
            throw response.message;
          }
          if (response.items.length === 0) {
            return do_post_config_group();
          } else {
            return do_get_config_group_item(0, response.items);
          }
        } catch (error1) {
          err = error1;
          error = err;
          return do_end();
        }
      });
    } catch (error1) {
      err = error1;
      error = err;
      return do_end();
    }
  };

  // ## Depencendies
  utils = require('../../utils');

  path = require('path');

  ({merge} = require('nikita/lib/misc'));

}).call(this);

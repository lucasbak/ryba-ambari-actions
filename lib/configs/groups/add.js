// Generated by CoffeeScript 2.1.1
  // # Ambari Configs Groups

  // Create ambari config groups [REST API v2](https://github.com/apache/ambari/blob/trunk/ambari-server/docs/api/v1)

  // * `password` (string)
  //   Ambari Administrator password.
  // * `url` (string)   
  //   Ambari External URL.
  // * `username` (string)
  //   Ambari Administrator username.
  // * `cluster_name` (string)   
  //   Name of the cluster, required
  // * `group_name` (string)   
  //   The config groups name, required
  // * `description` (string)   
  //   description associated to config group
  // * `tag` (string)   
  //   tag of the config groups, required
  //   Tha tag is wht identified uniquely on admin side the config groups
  // * `hosts` (string|array)   
  //   hosts which should belong to config group.
  // * `desired_configs` (object)   
  //   The object describing files types and properties.
  //   the key is the configuration_type, value are the properties.

  // ## Exemple

  // ```js
  // configs.groups({
  //   "username": 'ambari_admin',
  //   "password": 'ambari_secret',
  //   "url": "http://ambari.server.com",
  //   "cluster_name": 'ryba_test',
  //   "group_name": "compute_worker"
  //   "tag": "a tag"
  //   "description": "yarn high compute power"
  //   "hosts": ['worker01.metal.ryba']
  //   "desired_configs": {
  //     "type: "hdfs-site",
  //     "tag": "advances hdfs site",
  //     "properties": {
  //       "datanode.dir": "[DISK]file://data/1/hdfs"
  //       }  
  //   }
  //   }
  // }, function(err, status){
  //   console.log( err ? err.message : "Config groups CREATED/UPDATED: " + status)
  // })
  // ```

  // ## Source Code
  // This functions does a single post request with desired_configs and config_group.
  // Hosts can be empty as the config group can be uptade with a later PUT request.
var merge, path, utils,
  indexOf = [].indexOf;

module.exports = function(options, callback) {
  var config, do_end, do_get_config_group_item, do_post_config_group, err, error, hostname, i, k, len, name, opts, path, port, ref, ref1, status, v, value;
  if (options.debug) {
    process.stdout.write("Entering config.grous.add\n");
  }
  error = null;
  status = false;
  if (options.debug == null) {
    options.debug = false;
  }
  if (options.merge == null) {
    options.merge = true;
  }
  do_end = function() {
    if (callback != null) {
      return callback(error, status);
    }
    return new Promise(function(fullfil, reject) {
      if (error != null) {
        reject(error);
      }
      return fullfil(status);
    });
  };
  try {
    if (!options.username) {
      throw Error('Required Options: username');
    }
    if (!options.password) {
      throw Error('Required Options: password');
    }
    if (!options.url) {
      throw Error('Required Options: url');
    }
    if (!options.cluster_name) {
      throw Error('Required Options: cluster_name');
    }
    if (!options.group_name) {
      throw Error('Required Options: group_name');
    }
    if (!options.tag) {
      throw Error('Required Options: tag');
    }
    if (!options.desired_configs) {
      throw Error('Required Options: desired_configs');
    }
    if (!Array.isArray(options.desired_configs)) {
      options.desired_configs = [options.desired_configs];
    }
    if (options.hosts == null) {
      options.hosts = [];
    }
    if (!Array.isArray(options.hosts)) {
      options.hosts = [options.hosts];
    }
    if (options.description == null) {
      options.description = `config group cluster: ${options.cluster_name} group ${options.group_name}`;
    }
    [hostname, port] = options.url.split("://")[1].split(':');
    if (options.sslEnabled == null) {
      options.sslEnabled = options.url.split('://')[0] === 'https';
    }
    path = `/api/v1/clusters/${options.cluster_name}`;
    opts = {
      hostname: hostname,
      port: port,
      rejectUnauthorized: false,
      headers: utils.headers(options),
      sslEnabled: options.sslEnabled
    };
    ref = options.desired_configs;
    //check desired_configs keys
    for (i = 0, len = ref.length; i < len; i++) {
      config = ref[i];
      for (k in config) {
        v = config[k];
        if (!config.type) {
          throw Error("Missing config.type");
        }
        if (!config.tag) {
          throw Error("Missing config.tag");
        }
        if (!config.properties) {
          throw Error("Missing config.properties");
        }
        ref1 = config.properties;
        for (name in ref1) {
          value = ref1[name];
          if (Array.isArray(value)) {
            config.properties[name] = value.join(',');
          }
        }
      }
    }
    // ## Get Config Group Item
    // get groupname and tag at index i to check if matches options.tag and options.group_name
    do_get_config_group_item = function(index, configs) {
      config = configs[index];
      opts['method'] = 'GET';
      opts.path = config.href;
      return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
        var do_update_config, host, j, l, len1, len2, ref2, ref3, should_update;
        try {
          if (err) {
            throw err;
          }
          response = JSON.parse(response);
          if (parseInt(statusCode) !== 200) {
            throw response.message;
          }
          if ((response.ConfigGroup.group_name === options.group_name) && (response.ConfigGroup.tag === options.tag)) {
            if (options != null) {
              options.log({
                message: `Config group ${options.group_name} found via API`,
                level: 'INFO',
                module: 'ryba-ambari-actions/configs/groups/add'
              });
            }
            //check config groups are identical
            should_update = false;
            ref2 = response.ConfigGroup.hosts.map(function(host) {
              return host.host_name;
            });
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              host = ref2[j];
              if (indexOf.call(options.hosts, host) < 0) {
                should_update = true;
                if (options != null) {
                  options.log({
                    message: `Current Config group ${options.group_name} does not contain host ${host}`,
                    level: 'INFO',
                    module: 'ryba-ambari-actions/configs/groups/add'
                  });
                }
              }
            }
            ref3 = options.hosts;
            for (l = 0, len2 = ref3.length; l < len2; l++) {
              host = ref3[l];
              if (indexOf.call(response.ConfigGroup.hosts.map(function(host) {
                return host.host_name;
              }), host) < 0) {
                should_update = true;
                if (options != null) {
                  options.log({
                    message: `New Config group ${options.group_name} does not contain host ${host}`,
                    level: 'INFO',
                    module: 'ryba-ambari-actions/configs/groups/add'
                  });
                }
              }
            }
            do_update_config = function() {
              var newConfigGroup;
              opts['method'] = 'PUT';
              opts.path = `${path}/config_groups/${config.ConfigGroup.id}`;
              newConfigGroup = {
                ConfigGroup: {
                  cluster_name: options.cluster_name,
                  group_name: options.group_name,
                  tag: options.tag,
                  description: options.description,
                  hosts: options.hosts.map(function(host) {
                    return {
                      host_name: host
                    };
                  }),
                  desired_configs: options.desired_configs
                }
              };
              opts.content = JSON.stringify(newConfigGroup);
              if (options != null) {
                options.log({
                  message: `Will update Config group ${options.group_name} with id ${config.ConfigGroup.id} via API`,
                  level: 'INFO',
                  module: 'ryba-ambari-actions/configs/groups/add'
                });
              }
              return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
                try {
                  if (err) {
                    throw err;
                  }
                  console.log(err, statusCode, response);
                  switch (parseInt(statusCode)) {
                    case 200:
                      if (options != null) {
                        options.log({
                          message: `Config group ${options.group_name} updated via API`,
                          level: 'INFO',
                          module: 'ryba-ambari-actions/configs/groups/add'
                        });
                      }
                      status = true;
                      index = index + 1;
                      if (index === configs.length) {
                        return do_end();
                      } else {
                        return do_get_config_group_item(index, configs);
                      }
                      break;
                    case 409:
                      status = false;
                      index = index + 1;
                      if (index === configs.length) {
                        return do_end();
                      } else {
                        return do_get_config_group_item(index, configs);
                      }
                      break;
                    default:
                      error = Error(response.message);
                      return do_end();
                  }
                } catch (error1) {
                  err = error1;
                  error = err;
                  return do_end();
                }
              });
            };
            if (should_update) {
              return do_update_config();
            }
            opts.path = response.ConfigGroup.desired_configs[0].href;
            opts['method'] = 'GET';
            if (options != null) {
              options.log({
                message: `Reading current properties Config group ${options.group_name} updated via API`,
                level: 'INFO',
                module: 'ryba-ambari-actions/configs/groups/add'
              });
            }
            if (options != null) {
              options.log({
                message: `url: ${opts.path}`,
                level: 'INFO',
                module: 'ryba-ambari-actions/configs/groups/add'
              });
            }
            return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
              var diff_props, len3, m, prop, ref4, ref5;
              diff_props = [];
              try {
                if (err) {
                  throw err;
                }
                response = JSON.parse(response);
                if (parseInt(statusCode) !== 200) {
                  throw response.message;
                }
                ref4 = response.items[0].properties;
                for (prop in ref4) {
                  v = ref4[prop];
                  if (v !== options.desired_configs[0].properties[prop]) {
                    should_update = true;
                    diff_props.push(prop);
                  }
                }
                ref5 = options.desired_configs[0].properties;
                for (prop in ref5) {
                  v = ref5[prop];
                  if (v !== response.items[0].properties[prop]) {
                    should_update = true;
                    if (diff_props.indexOf(prop) === -1) {
                      diff_props.push(prop);
                    }
                  }
                }
                for (m = 0, len3 = diff_props.length; m < len3; m++) {
                  prop = diff_props[m];
                  if (options != null) {
                    options.log({
                      message: `New Config group ${options.group_name} property ${prop} was ${response.items[0].properties[prop]} and is now ${options.desired_configs[0].properties[prop]}`,
                      level: 'INFO',
                      module: 'ryba-ambari-actions/configs/groups/add'
                    });
                  }
                }
                if (should_update) {
                  return do_update_config();
                } else {
                  return do_end();
                }
              } catch (error1) {
                err = error1;
                error = err;
                return do_end();
              }
            });
          } else {
            //# check if the index is the arrya's length (meaning that allitems have been checked)
            index = index + 1;
            if (index === configs.length) {
              return do_post_config_group(); //if get the length of the array without matching, mean the config group does not exist
            } else {
              return do_get_config_group_item(index, configs);
            }
          }
        } catch (error1) {
          err = error1;
          error = err;
          return do_end();
        }
      });
    };
    do_post_config_group = function() {
      var newConfigGroup;
      opts['method'] = 'POST';
      opts.path = `${path}/config_groups`;
      newConfigGroup = {
        ConfigGroup: {
          cluster_name: options.cluster_name,
          group_name: options.group_name,
          tag: options.tag,
          description: options.description,
          hosts: options.hosts.map(function(host) {
            return {
              host_name: host
            };
          }),
          desired_configs: options.desired_configs
        }
      };
      opts.content = JSON.stringify(newConfigGroup);
      console.log(opts);
      if (options.debug) {
        process.stdout.write(`config.grous.add: post configGroup ${options.group_name}\n`);
      }
      // opts.json = true
      return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
        try {
          if (err) {
            throw err;
          }
          response = JSON.parse(response);
          switch (parseInt(statusCode)) {
            case 201:
              if (options.debug) {
                process.stdout.write(`config.grous.add: created configGroup ${options.config_name}\n`);
              }
              status = true;
              return do_end();
            case 409:
              status = false;
              return do_end();
            default:
              throw Error(response.message);
          }
        } catch (error1) {
          err = error1;
          error = err;
          return do_end();
        }
      });
    };
    opts['method'] = 'GET';
    opts.path = `${path}/config_groups`;
    return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
      try {
        if (err) {
          throw err;
        }
        response = JSON.parse(response);
        if (parseInt(statusCode) !== 200) {
          throw response.message;
        }
        if (response.items.length === 0) {
          return do_post_config_group();
        } else {
          return do_get_config_group_item(0, response.items);
        }
      } catch (error1) {
        err = error1;
        error = err;
        return do_end();
      }
    });
  } catch (error1) {
    err = error1;
    error = err;
    return do_end();
  }
};

// ## Depencendies
utils = require('../../utils');

path = require('path');

({merge} = require('nikita/lib/misc'));

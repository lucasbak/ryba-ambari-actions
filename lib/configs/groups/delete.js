// Generated by CoffeeScript 2.3.2
(function() {
  // # Ambari Configs Groups

  // Create ambari config groups [REST API v2](https://github.com/apache/ambari/blob/trunk/ambari-server/docs/api/v1)

  // * `password` (string)
  //   Ambari Administrator password.
  // * `url` (string)   
  //   Ambari External URL.
  // * `username` (string)
  //   Ambari Administrator username.
  // * `cluster_name` (string)   
  //   Name of the cluster, required
  // * `group_name` (string)   
  //   The config groups name, required
  // * `tag` (string)   
  //   tag of the config groups, required
  //   Tha tag is wht identified uniquely on admin side the config groups
  // * `id` (int)
  //   the id of the config groups to delete
  //   If no id is provided, the group_name and tag should be provided

  // ## Exemple

  // ```js
  // configs.groups({
  //   "username": 'ambari_admin',
  //   "password": 'ambari_secret',
  //   "url": "http://ambari.server.com",
  //   "cluster_name": 'ryba_test',
  //   "group_name": "compute_worker"
  //   "tag": "a tag"
  //   "description": "yarn high compute power"
  //   "hosts": ['worker01.metal.ryba']
  //   "desired_configs": {
  //     "type: "hdfs-site",
  //     "tag": "advances hdfs site",
  //     "properties": {
  //       "datanode.dir": "[DISK]file://data/1/hdfs"
  //       }  
  //   }
  //   }
  // }, function(err, status){
  //   console.log( err ? err.message : "Config groups CREATED/UPDATED: " + status)
  // })
  // ```

  // ## Source Code
  // This functions does a single post request with desired_configs and config_group.
  // Hosts can be empty as the config group can be uptade with a later PUT request.
  var merge, path, utils;

  module.exports = function(options, callback) {
    var config, do_delete_id, do_end, do_search_items, err, error, hostname, i, k, len, opts, path, port, ref, status, v;
    if (typeof options.options === 'object') {
      options = options.options;
    }
    if (options.debug) {
      process.stdout.write("Entering config.grous.delete\n");
    }
    error = null;
    status = false;
    if (options.debug == null) {
      options.debug = false;
    }
    if (options.merge == null) {
      options.merge = true;
    }
    do_end = function() {
      if (callback != null) {
        return callback(error, status);
      }
      return new Promise(function(fullfil, reject) {
        if (error != null) {
          reject(error);
        }
        return fullfil(status);
      });
    };
    try {
      if (!options.username) {
        throw Error('Required Options: username');
      }
      if (!options.password) {
        throw Error('Required Options: password');
      }
      if (!options.url) {
        throw Error('Required Options: url');
      }
      if (!options.cluster_name) {
        throw Error('Required Options: cluster_name');
      }
      if (!options.group_name) {
        throw Error('Required Options: group_name');
      }
      if (!options.tag) {
        throw Error('Required Options: tag');
      }
      if (!options.desired_configs) {
        throw Error('Required Options: desired_configs');
      }
      if (!Array.isArray(options.desired_configs)) {
        options.desired_configs = [options.desired_configs];
      }
      if (options.hosts == null) {
        options.hosts = [];
      }
      if (options.description == null) {
        options.description = `config group cluster: ${options.cluster_name} group ${options.config_name}`;
      }
      [hostname, port] = options.url.split("://")[1].split(':');
      if (options.sslEnabled == null) {
        options.sslEnabled = options.url.split('://')[0] === 'https';
      }
      path = `/api/v1/clusters/${options.cluster_name}`;
      opts = {
        hostname: hostname,
        port: port,
        rejectUnauthorized: false,
        headers: utils.headers(options),
        sslEnabled: options.sslEnabled
      };
      ref = options.desired_configs;
      //check desired_configs keys
      for (i = 0, len = ref.length; i < len; i++) {
        config = ref[i];
        for (k in config) {
          v = config[k];
          if (!config.type) {
            throw Error(Missing("config.type"));
          }
          if (!config.tag) {
            throw Error(Missing("config.tag"));
          }
          if (!config.properties) {
            throw Error(Missing("config.properties"));
          }
        }
      }
      opts['method'] = 'GET';
      path = `${path}/config_groups`;
      do_search_items = function() {
        var search_item;
        if (options.debug) {
          process.stdout.write("Search config groups item\n");
        }
        //config groups are identified by id
        // as a consequence need to compare group name and tag to delete if not id is provided
        search_item = function(index, items) {
          var item;
          item = items[index];
          opts.path = `${path}/${item.ConfigGroup.id}`;
          opts.method = 'GET';
          if (options.debug) {
            process.stdout.write(`Compare group item  with id nÂ° ${item.ConfigGroup.id}\n`);
          }
          return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
            try {
              if (err) {
                throw err;
              }
              if (parseInt(statusCode) !== 200) {
                throw Error(response.message);
              }
              response = JSON.parse(response);
              if ((response.ConfigGroup.group_name === options.group_name) && (response.ConfigGroup.tag === options.tag)) {
                options.id = response.ConfigGroup.id;
                return do_delete_id();
              } else {
                index = index + 1;
                if (index === items.length) {
                  return search_item(index, items);
                } else {
                  return do_end();
                }
              }
            } catch (error1) {
              err = error1;
              error = err;
              return do_end();
            }
          });
        };
        opts.method = 'GET';
        opts.path = path;
        if (options.debug) {
          process.stdout.write("Searching items by id\n");
        }
        return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
          try {
            if (err) {
              throw err;
            }
            if (parseInt(statusCode) !== 200) {
              throw Error(response.message);
            }
            response = JSON.parse(response);
            if (response.items.length > 0) {
              return search_item(0, response.items);
            } else {
              return do_end();
            }
          } catch (error1) {
            err = error1;
            error = err;
            return do_end();
          }
        });
      };
      do_delete_id = function() {
        if (options.debug) {
          process.stdout.write(`Deleting by id ${options.id}\n`);
        }
        opts.path = `${path}/${options.id}`;
        opts.method = 'DELETE';
        return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
          try {
            if (err) {
              throw err;
            }
            if (parseInt(statusCode) !== 200) {
              response = JSON.parse(response);
              throw Error(response.message);
            }
            status = true;
            return do_end();
          } catch (error1) {
            err = error1;
            error = err;
            return do_end();
          }
        });
      };
      if (options.id) {
        return do_delete_id();
      } else {
        return do_search_items();
      }
    } catch (error1) {
      err = error1;
      error = err;
      return do_end();
    }
  };

  // ## Depencendies
  utils = require('../../utils');

  path = require('path');

  ({merge} = require('nikita/lib/misc'));

}).call(this);

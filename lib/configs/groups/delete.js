// Generated by CoffeeScript 2.1.1
// # Ambari Configs Groups

// Create ambari config groups [REST API v2](https://github.com/apache/ambari/blob/trunk/ambari-server/docs/api/v1)

// * `password` (string)
//   Ambari Administrator password.
// * `url` (string)   
//   Ambari External URL.
// * `username` (string)
//   Ambari Administrator username.
// * `cluster_name` (string)   
//   Name of the cluster, required
// * `group_name` (string)   
//   The config groups name, required
// * `tag` (string)   
//   tag of the config groups, required
//   Tha tag is wht identified uniquely on admin side the config groups
// * `id` (int)
//   the id of the config groups to delete
//   If no id is provided, the group_name and tag should be provided

// ## Exemple

// ```js
// configs.groups({
//   "username": 'ambari_admin',
//   "password": 'ambari_secret',
//   "url": "http://ambari.server.com",
//   "cluster_name": 'ryba_test',
//   "group_name": "compute_worker"
//   "tag": "a tag"
//   "description": "yarn high compute power"
//   "hosts": ['worker01.metal.ryba']
//   "desired_configs": {
//     "type: "hdfs-site",
//     "tag": "advances hdfs site",
//     "properties": {
//       "datanode.dir": "[DISK]file://data/1/hdfs"
//       }  
//   }
//   }
// }, function(err, status){
//   console.log( err ? err.message : "Config groups CREATED/UPDATED: " + status)
// })
// ```

// ## Source Code
// This functions does a single post request with desired_configs and config_group.
// Hosts can be empty as the config group can be uptade with a later PUT request.
var merge, path, utils;

module.exports = function(options, callback) {
  var config, do_delete_id, do_end, do_search_items, err, error, hostname, i, k, len, opts, path, port, ref, status, v;
  if (options.debug) {
    process.stdout.write("Entering config.grous.delete\n");
  }
  error = null;
  status = false;
  if (options.debug == null) {
    options.debug = false;
  }
  if (options.merge == null) {
    options.merge = true;
  }
  do_end = function() {
    if (callback != null) {
      return callback(error, status);
    }
    return new Promise(function(fullfil, reject) {
      if (error != null) {
        reject(error);
      }
      return fullfil(status);
    });
  };
  try {
    if (!options.username) {
      throw Error('Required Options: username');
    }
    if (!options.password) {
      throw Error('Required Options: password');
    }
    if (!options.url) {
      throw Error('Required Options: url');
    }
    if (!options.cluster_name) {
      throw Error('Required Options: cluster_name');
    }
    if (!options.group_name) {
      throw Error('Required Options: group_name');
    }
    if (!options.tag) {
      throw Error('Required Options: tag');
    }
    if (!options.desired_configs) {
      throw Error('Required Options: desired_configs');
    }
    if (!Array.isArray(options.desired_configs)) {
      options.desired_configs = [options.desired_configs];
    }
    if (options.hosts == null) {
      options.hosts = [];
    }
    if (options.description == null) {
      options.description = `config group cluster: ${options.cluster_name} group ${options.config_name}`;
    }
    [hostname, port] = options.url.split("://")[1].split(':');
    if (options.sslEnabled == null) {
      options.sslEnabled = options.url.split('://')[0] === 'https';
    }
    path = `/api/v1/clusters/${options.cluster_name}`;
    opts = {
      hostname: hostname,
      port: port,
      rejectUnauthorized: false,
      headers: utils.headers(options),
      sslEnabled: options.sslEnabled
    };
    ref = options.desired_configs;
    //check desired_configs keys
    for (i = 0, len = ref.length; i < len; i++) {
      config = ref[i];
      for (k in config) {
        v = config[k];
        if (!config.type) {
          throw Error(Missing("config.type"));
        }
        if (!config.tag) {
          throw Error(Missing("config.tag"));
        }
        if (!config.properties) {
          throw Error(Missing("config.properties"));
        }
      }
    }
    opts['method'] = 'GET';
    path = `${path}/config_groups`;
    do_search_items = function() {
      var search_item;
      if (options.debug) {
        process.stdout.write("Search config groups item\n");
      }
      search_item = function(index, items) {
        var item;
        item = items[index];
        opts.path = `${path}/${item.ConfigGroup.id}`;
        opts.method = 'GET';
        if (options.debug) {
          process.stdout.write(`Compare group item  with id nÂ° ${item.ConfigGroup.id}\n`);
        }
        return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
          try {
            if (err) {
              throw err;
            }
            if (parseInt(statusCode) !== 200) {
              throw Error(response.message);
            }
            response = JSON.parse(response);
            if ((response.ConfigGroup.group_name === options.group_name) && (response.ConfigGroup.tag === options.tag)) {
              options.id = response.ConfigGroup.id;
              return do_delete_id();
            } else {
              index = index + 1;
              if (index === items.length) {
                return search_item(index, items);
              } else {
                return do_end();
              }
            }
          } catch (error1) {
            err = error1;
            error = err;
            return do_end();
          }
        });
      };
      opts.method = 'GET';
      opts.path = path;
      return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
        try {
          if (err) {
            throw err;
          }
          if (parseInt(statusCode) !== 200) {
            throw Error(response.message);
          }
          response = JSON.parse(response);
          if (response.items.length > 0) {
            return search_item(0, response.items);
          } else {
            return do_end();
          }
        } catch (error1) {
          err = error1;
          error = err;
          return do_end();
        }
      });
    };
    do_delete_id = function() {
      if (options.debug) {
        process.stdout.write(`Deleting by id ${options.id}\n`);
      }
      opts.path = `${path}/${options.id}`;
      opts.method = 'DELETE';
      return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
        try {
          if (err) {
            throw err;
          }
          if (parseInt(statusCode) !== 200) {
            response = JSON.parse(response);
            throw Error(response.message);
          }
          status = true;
          return do_end();
        } catch (error1) {
          err = error1;
          error = err;
          return do_end();
        }
      });
    };
    if (options.id) {
      return do_delete_id();
    } else {
      return do_search_items();
    }
  } catch (error1) {
    err = error1;
    error = err;
    return do_end();
  }
};

// ## Depencendies
utils = require('../../utils');

path = require('path');

({merge} = require('nikita/lib/misc'));

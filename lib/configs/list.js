// Generated by CoffeeScript 2.1.1
// # Ambari Configs update

// Get config hsitory for by service name. It does not use rest api, but custom url as used by webui.

// * `password` (string)
//   Ambari Administrator password.
// * `url` (string)   
//   Ambari External URL.
// * `username` (string)
//   Ambari Administrator username.
// * `cluster_name` (string)   
//   Name of the cluster, required
// * `service` (string)   
//   service name to get config on, required.     
// * `fields` (array).   
//   Array of fields to return. By default all fileds are returned. Valid fields:
//    * `service_config_version`
//    * `hosts`
//    * `group_id`
//    * `group_name`
//    * `is_current`
//    * `createtime`
//    * `service_name`
//    * `service_config_version_note`
//    * `stack_id`
//    * `is_cluster_compatible`
// * `tag` (number)   
//   number of tag to get historic on. By default all tag are returned.   
// * `sortBy` (string)   
//   sort result by `DESC` or `ASC`. `DESC` by default.
// * `user` (string)   
//   filter on config authof. By default all authors are returned
// * `version` (string)
//   get only some config version. By default all versions are returned.

// ## Exemple

// ```js
// configs.list({
//   "username": 'ambari_admin',
//   "password": 'ambari_secret',
//   "url": "http://ambari.server.com",
//   "service": 'HDFS'
//   }
// }, function(err, status, properties){
//   console.log( err ? err.message : "Properties are: " + properties)
// })
// ```
var utils;

module.exports = function(options, callback) {
  var do_end, err, error, hostname, itemsReturn, opts, path, port, properties, ref, service_config_version, service_list_config, services, status;
  if (typeof options.options === 'object') {
    options = options.options;
  }
  error = null;
  properties = null;
  status = false;
  itemsReturn = null;
  if (options.debug == null) {
    options.debug = false;
  }
  do_end = function() {
    if (callback != null) {
      callback(error, itemsReturn);
    }
    return new Promise(function(fullfil, reject) {
      if (error != null) {
        reject(error);
      }
      return fullfil(itemsReturn);
    });
  };
  try {
    if (!options.service) {
      throw Error('Missing service name');
    }
    options.service = options.service.toUpperCase();
    if (options.sortBy == null) {
      options.sortBy = 'desc';
    }
    options.sortBy = options.sortBy.toLowerCase();
    if (options.fields == null) {
      options.fields = ['service_config_version', 'user', 'hosts', 'group_id', 'group_name', 'is_current', 'createtime', 'service_name', 'service_config_version_note', 'stack_id', 'is_cluster_compatible'];
    }
    options.fields.push('user');
    if ((ref = options.sortBy) !== 'desc' && ref !== 'asc') {
      throw Error('sortBy not valid: desc or asc expected');
    }
    if (options.tag != null) {
      if (typeof options.tag !== 'number') {
        throw Error('Number of tag not a number');
      }
    }
    [hostname, port] = options.url.split("://")[1].split(':');
    if (hostname == null) {
      hostname = options.hostname;
    }
    if (port == null) {
      port = options.port;
    }
    if (options.sslEnabled == null) {
      options.sslEnabled = options.url.split('://')[0] === 'https';
    }
    service_config_version = 'service_config_version';
    service_list_config = `&fields=${options.fields.join(',')}&sortBy=service_config_version.${options.sortBy}&minimal_response=true`;
    if (options.version) {
      // services = if Array.isArray options.service then options.service.join(',') else options.service
      services = ['RANGER_KMS', 'AMBARI_METRICS', 'RANGER', 'YARN', 'KAFKA', 'ZOOKEEPER', 'ATLAS', 'HBASE', 'HIVE', 'KNOX', 'STORM', 'AMBARI_INFRA_SOLR', 'HDFS'];
      service_config_version = `&${service_config_version}.in(${options.version.join()})|service_name.in(${services})`;
    }
    path = `/api/v1/clusters/${options.cluster_name}/configurations/service_config_versions?service_name=${options.service}${(options.version ? service_config_version : service_list_config)}`;
    opts = {
      hostname: hostname,
      port: port,
      rejectUnauthorized: false,
      headers: utils.headers(options),
      sslEnabled: options.sslEnabled
    };
    opts['method'] = 'GET';
    opts.path = `${path}`;
    return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
      var items, result;
      if (err) {
        throw err;
      }
      if (statusCode === 404) {
        throw Error('Service not found');
      }
      if (statusCode !== 200) {
        throw Error(response.message);
      }
      result = JSON.parse(response);
      if (options.tag != null) {
        items = result.items.slice(0, options.tag);
      }
      if (options.user) {
        items = result.items.filter(function(item) {
          return item.user === options.user;
        });
      }
      itemsReturn = result.items;
      // console.log items
      status = true;
      return do_end();
    });
  } catch (error1) {
    err = error1;
    error = err;
    return do_end();
  }
};

// ## Depencendies
utils = require('../utils');

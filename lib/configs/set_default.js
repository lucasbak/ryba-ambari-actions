// Generated by CoffeeScript 2.3.2
(function() {
  // # Ambari Get Default Configuration for Service(s)

  // This module wraps `ryba-ambari-actions/services/default_informations` function
  // to provide default configuration per services based on cluster layout.

  // * `password` (string)
  //   Ambari Administrator password.
  // * `url` (string)   
  //   Ambari External URL.
  // * `username` (string)
  //   Ambari Administrator username.
  // * `stack_name` (string)
  //   Thw stack name.
  // * `stack_version` (string)   
  //   The stack version of the configuration request.
  // * `installed_services` (string|array)   
  //   List of service that should be installed on cluster.   
  // * `target_services` (string|array)   
  //   List of service to compute the configuration for.   

  // ## Exemple

  // ```js
  // configs.get_default({
  //   "username": 'ambari_admin',
  //   "password": 'ambari_secret',
  //   "url": "http://ambari.server.com",
  //   "stack_version": '2.6',
  //   "services": ['HDFS','KERBEROS','YARN']
  //   "target_services": ['PIG']
  //   }
  // }, function(err, status){
  //   console.log( err ? err.message : "Properties UPDATED: " + status)
  // })
  // ```

  // ## Source Code
  var action_config_update, action_default_informations, merge, path, utils;

  module.exports = function(options, callback) {
    var default_configuration_request, differences, do_end, err, error, i, j, len, len1, ref, ref1, response, services, srv, status;
    if (typeof options.options === 'object') {
      options = options.options;
    }
    error = null;
    differences = false;
    if (options.debug == null) {
      options.debug = false;
    }
    response = null;
    status = false;
    default_configuration_request = {};
    do_end = function() {
      if (callback != null) {
        return callback(error, status, response);
      }
      return new Promise(function(fullfil, reject) {
        if (error != null) {
          reject(error);
        }
        return fullfil(differences);
      });
    };
    try {
      if (!options.username) {
        throw Error('Required Options: username');
      }
      if (!options.password) {
        throw Error('Required Options: password');
      }
      if (!options.url) {
        throw Error('Required Options: url');
      }
      if (!options.cluster_name) {
        throw Error('Required Options: cluster_name');
      }
      if (!(options.installed_services || options.discover)) {
        throw Error('Required Options: installed_services');
      }
      if (!options.target_services) {
        throw Error('Required Options: target_services');
      }
      if (!options.stack_name) {
        throw Error('Required Options: stack_name');
      }
      if (!options.stack_version) {
        throw Error('Required Options: stack_version');
      }
      if (!Array.isArray(options.target_services)) {
        options.target_services = [options.target_services];
      }
      if (options.installed_services != null) {
        if (!Array.isArray(options.installed_services)) {
          options.installed_services = [options.installed_services];
        }
        ref = options.installed_services;
        for (i = 0, len = ref.length; i < len; i++) {
          srv = ref[i];
          if (srv !== 'KERBEROS' && srv !== 'RANGER' && srv !== 'HDFS' && srv !== 'YARN' && srv !== 'HIVE' && srv !== 'HBASE' && srv !== 'SQOOP' && srv !== 'OOZIE' && srv !== 'PIG' && srv !== 'TEZ' && srv !== 'NIFI' && srv !== 'KAFKA' && srv !== 'MAPREDUCE2' && srv !== 'ZOOKEEPER' && srv !== 'SPARK' && srv !== 'SPARK2' && srv !== 'KNOX' && srv !== 'AMBARI_METRICS' && srv !== 'LOGSEARCH' && srv !== 'ATLAS' && srv !== 'ZEPPELIN' && srv !== 'AMBARI_INFRA') {
            throw Error(`Unsupported service ${srv}`);
          }
        }
      }
      ref1 = options.target_services;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        srv = ref1[j];
        if (srv !== 'KERBEROS' && srv !== 'RANGER' && srv !== 'HDFS' && srv !== 'YARN' && srv !== 'HIVE' && srv !== 'HBASE' && srv !== 'SQOOP' && srv !== 'OOZIE' && srv !== 'PIG' && srv !== 'TEZ' && srv !== 'NIFI' && srv !== 'KAFKA' && srv !== 'MAPREDUCE2' && srv !== 'ZOOKEEPER' && srv !== 'SPARK' && srv !== 'SPARK2' && srv !== 'KNOX' && srv !== 'AMBARI_METRICS' && srv !== 'LOGSEARCH' && srv !== 'ATLAS' && srv !== 'ZEPPELIN' && srv !== 'AMBARI_INFRA') {
          throw Error(`Unsupported service ${srv}`);
        }
      }
      services = [];
      services.push(...options.target_services);
      return action_default_informations(options, function(err, status, informations) {
        var base, base1, base2, config_type, config_type_name, configuration, do_update_service_config, l, len2, len3, len4, m, model, n, name, property_name, ref2, ref3, ref4, service;
        try {
          if (err) {
            throw err;
          }
          if (options.discover) {
            if (options.installed_services == null) {
              options.installed_services = informations.discovered_services;
            }
          }
          services.push(...options.installed_services);
//loog through ieach service to get information
          for (l = 0, len2 = services.length; l < len2; l++) {
            service = services[l];
            if (default_configuration_request[service] == null) {
              default_configuration_request[service] = {};
            }
            ref2 = informations.items;
            for (m = 0, len3 = ref2.length; m < len3; m++) {
              srv = ref2[m];
              if (!((`${srv['StackServices'].service_name}` === `${service}`) && (`${srv['StackServices'].stack_name}` === `${options.stack_name}`) && (`${srv['StackServices'].stack_version}` === `${options.stack_version}`))) {
                //compare service_name, stack_name and stack_version
                continue;
              }
              ref3 = srv['StackServices'].config_types;
              for (config_type_name in ref3) {
                model = ref3[config_type_name];
                if (options.debug) {
                  console.log(`discover config type ${config_type_name}`);
                }
                if ((base = default_configuration_request[service])[config_type_name] == null) {
                  base[config_type_name] = {};
                }
              }
              if (Object.keys(default_configuration_request[service]).length === 0) {
                // for performance issue we do not loop through each properties to populate config type
                // because the loop would be done for each configuration type
                // so we just record the config-type-name and then iterate only once
                throw Error(`No config type found in Ambari for service ${service}`);
              }
              ref4 = srv.configurations;
              // console.log srv.configurations
              for (n = 0, len4 = ref4.length; n < len4; n++) {
                configuration = ref4[n];
                if (options.debug) {
                  // console.log configuration.href
                  console.log(`comparing property ${configuration['StackConfigurations'].property_name}`);
                }
                config_type = configuration['StackConfigurations']['type'].split('.xml')[0];
                if (options.debug) {
                  console.log(`- config type is ${config_type}`);
                }
                property_name = `${configuration['StackConfigurations']['property_name']}`;
                if ((base1 = default_configuration_request[service])[config_type] == null) {
                  base1[config_type] = {};
                }
                if ((base2 = default_configuration_request[service][config_type])[name = `${property_name}`] == null) {
                  base2[name] = configuration['StackConfigurations']['property_value'];
                }
              }
            }
          }
          do_update_service_config = function(index, target_services) {
            var do_update_service_config_type;
            service = target_services[index];
            do_update_service_config_type = function(index_config, configs) {
              var k, properties, ref5, ref6, ref7, v;
              config_type = configs[index_config];
              properties = default_configuration_request[service][config_type];
              options.config_type = config_type;
              options.properties = properties;
              //merge options bases on options.configurations object
              if (((ref5 = options.configurations) != null ? ref5[config_type] : void 0) != null) {
                ref6 = options.properties;
                for (k in ref6) {
                  v = ref6[k];
                  if (options.configurations[config_type][k] != null) {
                    properties[k] = options.configurations[config_type][k];
                  }
                }
                ref7 = options.configurations[config_type];
                for (k in ref7) {
                  v = ref7[k];
                  if (options.configurations[config_type][k] != null) {
                    properties[k] = options.configurations[config_type][k];
                  }
                }
              }
              return action_config_update(options, function(err, done) {
                status = status || done;
                if (err) {
                  error = err;
                  return do_end();
                } else {
                  index_config = index_config + 1;
                  //check if all type are done for a service
                  if (index_config === configs.length) {
                    index = index + 1;
                    //check if all target_services are done
                    if (index === target_services.length) {
                      return do_end();
                    } else {
                      return do_update_service_config(index, target_services);
                    }
                  } else {
                    return do_update_service_config_type(index_config, configs);
                  }
                }
              });
            };
            return do_update_service_config_type(0, Object.keys(default_configuration_request[service]));
          };
          return do_update_service_config(0, options.target_services);
        } catch (error1) {
          err = error1;
          error = err;
          return do_end();
        }
      });
    } catch (error1) {
      err = error1;
      error = err;
      return do_end();
    }
  };

  // ## Depencendies
  utils = require('../utils');

  path = require('path');

  ({merge} = require('nikita/lib/misc'));

  action_default_informations = require('../stacks/default_informations');

  action_config_update = require('./update');

}).call(this);

// Generated by CoffeeScript 2.1.1
// # Ambari Get Default Configuration for Service(s)

// This module wraps `ryba-ambari-actions/services/default_informations` function
// to provide default configuration per services based on cluster layout.

// * `password` (string)
//   Ambari Administrator password.
// * `url` (string)   
//   Ambari External URL.
// * `username` (string)
//   Ambari Administrator username.
// * `cluster_name`   
//   The target cluster.
// * `stack_name` (string)
//   Thw stack name.
// * `stack_version` (string)   
//   The stack version of the configuration request.
// * `service` (string)   
//   Service to update the kerberos_descriptor configuration.   
// * `component` (string)
//   The component of the service to update configuration about.   
// * `identities` (string|array)   
//   The identities object(s) to update, inside service'component configuration.   
//   note name key is mandatory inside an identity object   
// * `source` (string)
//   The source the default configuration is read from.   

// ## Exemple

// ```js
// kerberos.descriptor.update({
//   "username": 'ambari_admin',
//   "password": 'ambari_secret',
//   "url": "http://ambari.server.com",
//   "stack_version": '2.6',
//   "stack_name: "HDP",
//   "cluster_name": "rybatest",
//   "service": "HDFS",
//   "component": "NAMENODE",
//   "identities": {
//     "keytab": {
//         "configuration": "hadoop-env/hdfs_user_keytab",
//         "file": "${keytab_dir}/hdfs.headless.keytab",
//         "group": {
//           "access": "",
//           "name": "${cluster-env/user_group}"
//         },
//         "owner": {
//           "access": "r",
//           "name": "${hadoop-env/hdfs_user}"
//         }
//       },
//       "name": "hdfs",
//       "principal": {
//         "configuration": "hadoop-env/hdfs_principal_name",
//         "local_username": "${hadoop-env/hdfs_user}",
//         "type": "user",
//         "value": "${hadoop-env/hdfs_user}${principal_suffix}@${realm}"
//       }
//     }
//   }
// }, function(err, status){
//   console.log( err ? err.message : "Properties UPDATED: " + status)
// })
// ```

// ## Source Code
// Will iterate through each identities object of the service'component, and will merge
// it's value with the one given in option.
var get_kerberos_descriptor, merge, path, utils;

module.exports = function(options, callback) {
  var default_configuration_request, differences, do_end, err, error, ref, response, status;
  error = null;
  differences = false;
  if (options.debug == null) {
    options.debug = false;
  }
  response = null;
  status = false;
  default_configuration_request = {};
  do_end = function() {
    if (callback != null) {
      return callback(error, status, response);
    }
    return new Promise(function(fullfil, reject) {
      if (error != null) {
        reject(error);
      }
      return fullfil(differences);
    });
  };
  try {
    if (!options.username) {
      throw Error('Required Options: username');
    }
    if (!options.password) {
      throw Error('Required Options: password');
    }
    if (!options.url) {
      throw Error('Required Options: url');
    }
    if (!options.cluster_name) {
      throw Error('Required Options: cluster_name');
    }
    if ((!options.stack_name) && options.source === 'STACK') {
      throw Error('Required Options: stack_name');
    }
    if ((!options.stack_version) && options.source === 'STACK') {
      throw Error('Required Options: stack_version');
    }
    if ((!options.cluster_name) && options.source === 'COMPOSITE') {
      throw Error('Required Options: cluster_name');
    }
    if (options.stack_name) {
      if ((ref = options.stack_name) !== 'HDP' && ref !== 'HDF') {
        throw Error(`Unsupported Stack Name ${options.stack_name}`);
      }
    }
    if (!options.identities) {
      // throw Error 'Required Options: service' unless options.service
      // throw Error 'Required Options: component' unless options.component
      throw Error('Required Options: identities');
    }
    if (!Array.isArray(options.identities)) {
      options.identities = [options.identities];
    }
    return get_kerberos_descriptor(options, function(err, status, informations) {
      var do_cluster_level_configuration, do_service_or_component_level_configuration, hostname, opts, path, port;
      try {
        if (err) {
          throw err;
        }
        if (options.artifact_data == null) {
          options.artifact_data = options.source === 'STACK' ? informations.artifact_data : informations.kerberos_descriptor;
        }
        do_cluster_level_configuration = function() {
          var gl_id, global_identity, i, identity, len, ref1, results;
          ref1 = options.artifact_data.identities;
          results = [];
          for (gl_id = i = 0, len = ref1.length; i < len; gl_id = ++i) {
            global_identity = ref1[gl_id];
            results.push((function() {
              var j, len1, ref2, results1;
              ref2 = options.identities;
              results1 = [];
              for (j = 0, len1 = ref2.length; j < len1; j++) {
                identity = ref2[j];
                if (global_identity.name !== identity.name) {
                  continue;
                }
                options.artifact_data.identities[gl_id] = identity;
                results1.push(global_identity = identity);
              }
              return results1;
            })());
          }
          return results;
        };
        do_service_or_component_level_configuration = function() {
          var component, component_identity, i, identity, k_co_id, k_id, k_identity_id, k_srv_id, len, ref1, results, service, service_identity;
          ref1 = options.artifact_data.services;
          results = [];
          for (k_srv_id = i = 0, len = ref1.length; i < len; k_srv_id = ++i) {
            service = ref1[k_srv_id];
            if (service.name !== options.service) {
              continue;
            }
            if (options.component) {
              results.push((function() {
                var j, len1, ref2, results1;
                ref2 = service.components;
                results1 = [];
                for (k_co_id = j = 0, len1 = ref2.length; j < len1; k_co_id = ++j) {
                  component = ref2[k_co_id];
                  if (component.name !== options.component) {
                    continue;
                  }
                  results1.push((function() {
                    var k, len2, ref3, results2;
                    ref3 = component.identities;
                    results2 = [];
                    for (k_identity_id = k = 0, len2 = ref3.length; k < len2; k_identity_id = ++k) {
                      component_identity = ref3[k_identity_id];
                      results2.push((function() {
                        var l, len3, ref4, results3;
                        ref4 = options.identities;
                        results3 = [];
                        for (l = 0, len3 = ref4.length; l < len3; l++) {
                          identity = ref4[l];
                          if (component_identity.name !== identity.name) {
                            continue;
                          }
                          results3.push(options.artifact_data.services[k_srv_id].components[k_co_id].identities[k_identity_id] = identity);
                        }
                        return results3;
                      })());
                    }
                    return results2;
                  })());
                }
                return results1;
              })());
            } else {
              results.push((function() {
                var j, len1, ref2, results1;
                ref2 = service.identities;
                results1 = [];
                for (k_id = j = 0, len1 = ref2.length; j < len1; k_id = ++j) {
                  service_identity = ref2[k_id];
                  results1.push((function() {
                    var k, len2, ref3, results2;
                    ref3 = options.identities;
                    results2 = [];
                    for (k = 0, len2 = ref3.length; k < len2; k++) {
                      identity = ref3[k];
                      if (service_identity.name !== identity.name) {
                        continue;
                      }
                      results2.push(options.artifact_data.services[k_srv_id].identities[k_id] = identity);
                    }
                    return results2;
                  })());
                }
                return results1;
              })());
            }
          }
          return results;
        };
        if (options.service) {
          do_service_or_component_level_configuration();
        } else {
          do_cluster_level_configuration();
        }
        [hostname, port] = options.url.split("://")[1].split(':');
        if (options.sslEnabled == null) {
          options.sslEnabled = options.url.split('://')[0] === 'https';
        }
        path = `/api/v1/clusters/${options.cluster_name}/artifacts/kerberos_descriptor`;
        opts = {
          hostname: hostname,
          port: port,
          rejectUnauthorized: false,
          headers: utils.headers(options),
          sslEnabled: options.sslEnabled
        };
        opts.path = path;
        opts['method'] = 'GET';
        return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
          try {
            if (err) {
              throw err;
            }
            switch (parseInt(statusCode)) {
              case 200:
                opts['method'] = 'PUT';
                break;
              case 404:
                opts['method'] = 'POST';
                break;
              default:
                response = JSON.parse(response);
                throw Error(response.message);
            }
            opts.content = JSON.stringify({
              artifact_data: options.artifact_data
            });
            return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
              try {
                if (err) {
                  throw err;
                }
                if (statusCode !== 200 && statusCode !== 201) {
                  response = JSON.parse(response);
                  throw Error(response.message);
                } else {
                  status = true;
                  return do_end();
                }
              } catch (error1) {
                err = error1;
                error = err;
                return do_end();
              }
            });
          } catch (error1) {
            err = error1;
            error = err;
            return do_end();
          }
        });
      } catch (error1) {
        err = error1;
        error = err;
        return do_end();
      }
    });
  } catch (error1) {
    err = error1;
    error = err;
    return do_end();
  }
};

// ## Depencendies
utils = require('../../utils');

path = require('path');

({merge} = require('nikita/lib/misc'));

get_kerberos_descriptor = require('../../stacks/kerberos_descriptor');

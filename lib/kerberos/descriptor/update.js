// Generated by CoffeeScript 2.3.2
(function() {
  // # Ambari Get Default Configuration for Service(s)

  // This module wraps `ryba-ambari-actions/services/default_informations` function
  // to provide default configuration per services based on cluster layout.

  // * `password` (string)
  //   Ambari Administrator password.
  // * `url` (string)   
  //   Ambari External URL.
  // * `username` (string)
  //   Ambari Administrator username.
  // * `cluster_name`   
  //   The target cluster.
  // * `stack_name` (string)
  //   Thw stack name.
  // * `stack_version` (string)   
  //   The stack version of the configuration request.
  // * `service` (string)   
  //   Service to update the kerberos_descriptor configuration.   
  // * `component` (string)
  //   The component of the service to update configuration about.   
  // * `identities` (string|array)   
  //   The identities object(s) to update, inside service'component configuration.   
  //   note name key is mandatory inside an identity object   
  // * `source` (string)
  //   The source the default configuration is read from.   

  // ## Exemple

  // ```js
  // kerberos.descriptor.update({
  //   "username": 'ambari_admin',
  //   "password": 'ambari_secret',
  //   "url": "http://ambari.server.com",
  //   "stack_version": '2.6',
  //   "stack_name: "HDP",
  //   "cluster_name": "rybatest",
  //   "service": "HDFS",
  //   "component": "NAMENODE",
  //   "identities": {
  //     "keytab": {
  //         "configuration": "hadoop-env/hdfs_user_keytab",
  //         "file": "${keytab_dir}/hdfs.headless.keytab",
  //         "group": {
  //           "access": "",
  //           "name": "${cluster-env/user_group}"
  //         },
  //         "owner": {
  //           "access": "r",
  //           "name": "${hadoop-env/hdfs_user}"
  //         }
  //       },
  //       "name": "hdfs",
  //       "principal": {
  //         "configuration": "hadoop-env/hdfs_principal_name",
  //         "local_username": "${hadoop-env/hdfs_user}",
  //         "type": "user",
  //         "value": "${hadoop-env/hdfs_user}${principal_suffix}@${realm}"
  //       }
  //     }
  //   }
  // }, function(err, status){
  //   console.log( err ? err.message : "Properties UPDATED: " + status)
  // })
  // ```

  // ## Source Code
  // Will iterate through each identities object of the service'component, and will merge
  // it's value with the one given in option.
  var get_kerberos_descriptor, merge, path, utils;

  module.exports = function(options, callback) {
    var default_configuration_request, differences, do_end, err, error, ref, response, status;
    if (typeof options.options === 'object') {
      options = options.options;
    }
    error = null;
    differences = false;
    if (options.debug == null) {
      options.debug = false;
    }
    response = null;
    status = false;
    default_configuration_request = {};
    do_end = function() {
      if (callback != null) {
        return callback(error, status, response);
      }
      return new Promise(function(fullfil, reject) {
        if (error != null) {
          reject(error);
        }
        return fullfil(differences);
      });
    };
    try {
      if (!options.username) {
        throw Error('Required Options: username');
      }
      if (!options.password) {
        throw Error('Required Options: password');
      }
      if (!options.url) {
        throw Error('Required Options: url');
      }
      if (!options.cluster_name) {
        throw Error('Required Options: cluster_name');
      }
      if ((!options.stack_name) && options.source === 'STACK') {
        throw Error('Required Options: stack_name');
      }
      if ((!options.stack_version) && options.source === 'STACK') {
        throw Error('Required Options: stack_version');
      }
      if ((!options.cluster_name) && options.source === 'COMPOSITE') {
        throw Error('Required Options: cluster_name');
      }
      if (options.stack_name) {
        if ((ref = options.stack_name) !== 'HDP' && ref !== 'HDF') {
          throw Error(`Unsupported Stack Name ${options.stack_name}`);
        }
      }
      if (!options.identities) {
        // throw Error 'Required Options: service' unless options.service
        // throw Error 'Required Options: component' unless options.component
        throw Error('Required Options: identities');
      }
      if (!Array.isArray(options.identities)) {
        options.identities = [options.identities];
      }
      return get_kerberos_descriptor(options, function(err, status, informations) {
        var do_cluster_level_configuration, do_request, do_service_or_component_level_configuration, hostname, opts, path, port;
        try {
          if (err) {
            throw err;
          }
          if (options.artifact_data == null) {
            options.artifact_data = options.source === 'STACK' ? informations.artifact_data : informations.kerberos_descriptor;
          }
          // preapre the request body and headers
          [hostname, port] = options.url.split("://")[1].split(':');
          if (options.sslEnabled == null) {
            options.sslEnabled = options.url.split('://')[0] === 'https';
          }
          path = `/api/v1/clusters/${options.cluster_name}/artifacts/kerberos_descriptor`;
          opts = {
            hostname: hostname,
            port: port,
            rejectUnauthorized: false,
            headers: utils.headers(options),
            sslEnabled: options.sslEnabled
          };
          opts.path = path;
          opts['method'] = 'GET';
          do_request = function() {
            return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
              try {
                if (err) {
                  throw err;
                }
                switch (parseInt(statusCode)) {
                  case 200:
                    opts['method'] = 'PUT';
                    break;
                  case 404:
                    opts['method'] = 'POST';
                    break;
                  default:
                    response = JSON.parse(response);
                    throw Error(response.message);
                }
                opts.content = JSON.stringify({
                  artifact_data: options.artifact_data
                });
                return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
                  try {
                    if (err) {
                      throw err;
                    }
                    if (statusCode !== 200 && statusCode !== 201) {
                      response = JSON.parse(response);
                      throw Error(response.message);
                    } else {
                      status = true;
                      return do_end();
                    }
                  } catch (error1) {
                    err = error1;
                    error = err;
                    return do_end();
                  }
                });
              } catch (error1) {
                err = error1;
                error = err;
                return do_end();
              }
            });
          };
          // prepare the cluster global level configuration function
          do_cluster_level_configuration = function() {
            var gl_id, global_identity, i, identity, j, len, len1, ref1, ref2;
            ref1 = options.artifact_data.identities;
            for (gl_id = i = 0, len = ref1.length; i < len; gl_id = ++i) {
              global_identity = ref1[gl_id];
              ref2 = options.identities;
              for (j = 0, len1 = ref2.length; j < len1; j++) {
                identity = ref2[j];
                if (global_identity.name !== identity.name) {
                  continue;
                }
                options.artifact_data.identities[gl_id] = identity;
                global_identity = identity;
              }
            }
            return do_request();
          };
          // prepare the service/component global level configuration function
          do_service_or_component_level_configuration = function() {
            var component, component_identity, i, identity, j, k, k_co_id, k_id, k_identity_id, k_srv_id, len, len1, len2, ref1, ref2, ref3, results, service, service_identity;
            ref1 = options.artifact_data.services;
            results = [];
            for (k_srv_id = i = 0, len = ref1.length; i < len; k_srv_id = ++i) {
              service = ref1[k_srv_id];
              if (service.name !== options.service) {
                continue;
              }
              if (options.component) {
                results.push((function() {
                  var j, k, l, len1, len2, len3, ref2, ref3, ref4, results1;
                  ref2 = service.components;
                  results1 = [];
                  for (k_co_id = j = 0, len1 = ref2.length; j < len1; k_co_id = ++j) {
                    component = ref2[k_co_id];
                    if (component.name !== options.component) {
                      continue;
                    }
                    ref3 = component.identities;
                    for (k_identity_id = k = 0, len2 = ref3.length; k < len2; k_identity_id = ++k) {
                      component_identity = ref3[k_identity_id];
                      ref4 = options.identities;
                      for (l = 0, len3 = ref4.length; l < len3; l++) {
                        identity = ref4[l];
                        if (component_identity.name !== identity.name) {
                          continue;
                        }
                        options.artifact_data.services[k_srv_id].components[k_co_id].identities[k_identity_id] = identity;
                      }
                    }
                    results1.push(do_request());
                  }
                  return results1;
                })());
              } else {
                ref2 = service.identities;
                for (k_id = j = 0, len1 = ref2.length; j < len1; k_id = ++j) {
                  service_identity = ref2[k_id];
                  ref3 = options.identities;
                  for (k = 0, len2 = ref3.length; k < len2; k++) {
                    identity = ref3[k];
                    if (service_identity.name !== identity.name) {
                      continue;
                    }
                    options.artifact_data.services[k_srv_id].identities[k_id] = identity;
                  }
                }
                results.push(do_request());
              }
            }
            return results;
          };
          if (options.service) {
            return do_service_or_component_level_configuration();
          } else {
            return do_cluster_level_configuration();
          }
        } catch (error1) {
          err = error1;
          error = err;
          return do_end();
        }
      });
    } catch (error1) {
      err = error1;
      error = err;
      return do_end();
    }
  };

  // ## Depencendies
  utils = require('../../utils');

  path = require('path');

  ({merge} = require('nikita/lib/misc'));

  get_kerberos_descriptor = require('../../stacks/kerberos_descriptor');

}).call(this);

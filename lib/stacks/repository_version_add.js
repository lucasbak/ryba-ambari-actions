// Generated by CoffeeScript 2.1.1
// # Ambari repository version add

// Add a repository version for given stack [REST API v2](https://github.com/apache/ambari/blob/trunk/ambari-server/docs/api/v1)
// The stack should exist as the target version

// * `password` (string)
//   Ambari Administrator password.
// * `url` (string)   
//   Ambari External URL.
// * `username` (string)
//   Ambari Administrator username.
// * `cluster_name` (string)   
//   Name of the cluster, optional
// * `stack_name` (string)   
//   name of the stack, required.
// * `stack_version` (string)   
//   version of the stack, required.  
// * `stack_name` (string)   
//   name of the stack, required.
// * `repository_version` (string)   
//   Fulle version of the target repository, required.  
// * `display_name` (string)   
//   display strong for the full version, required.  
// * `repositories` (object)
//     an object representing the repositories.
//     the key should be the operating system
//     the value should be an object containing all os' related repositories

// ## Exemple

// ```js
// nikita
// .stacks.repository_version_add({
//   "username": 'ambari_admin',
//   "password": 'ambari_secret',
//   "url": "http://ambari.server.com",
//   "cluster_name": 'my_cluster'
//   "name": 'HDFS'
//   }
// }, function(err, status){
//   console.log( err ? err.message : "Node Added To Cluster: " + status)
// })
// ```

// ## Source Code
var utils;

module.exports = function(options, callback) {
  var do_end, err, error, hostname, opts, path, port, status;
  error = null;
  status = false;
  if (options.debug == null) {
    options.debug = false;
  }
  do_end = function() {
    if (callback != null) {
      return callback(error, status);
    }
    return new Promise(function(fullfil, reject) {
      if (error != null) {
        reject(error);
      }
      return fullfil(status);
    });
  };
  try {
    if (!options.username) {
      throw Error('Required Options: username');
    }
    if (!options.password) {
      throw Error('Required Options: password');
    }
    if (!options.url) {
      throw Error('Required Options: url');
    }
    if (!options.stack_name) {
      throw Error('Required Options: stack_name');
    }
    if (!options.stack_version) {
      throw Error('Required Options: stack_version');
    }
    if (!options.display_name) {
      throw Error('Required Options: display_name');
    }
    if (!options.repository_version) {
      throw Error('Required Options: repository_version');
    }
    if (!options.cluster_name) {
      throw Error('Required Options: cluster_name');
    }
    if (!options.repositories) {
      throw Error('Required Options: repositories');
    }
    [hostname, port] = options.url.split("://")[1].split(':');
    if (options.sslEnabled == null) {
      options.sslEnabled = options.url.split('://')[0] === 'https';
    }
    path = `/api/v1/stacks/${options.stack_name}/versions/${options.stack_version}/repository_versions/`;
    opts = {
      hostname: hostname,
      port: port,
      rejectUnauthorized: false,
      headers: utils.headers(options),
      sslEnabled: options.sslEnabled
    };
    opts['method'] = 'GET';
    opts.path = `${path}`;
    return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
      var do_check_current;
      try {
        if (err) {
          throw err;
        }
        response = JSON.parse(response);
        if (parseInt(statusCode) !== 200) {
          throw Error(response.message);
        }
        //if the display name already exist, we consider its an update set metho to PUT
        do_check_current = function(index, items, cb) {
          var item;
          if (items.length === 0) {
            return cb(null, false);
          }
          item = items[index];
          opts['method'] = 'GET';
          opts.path = item.href;
          opts.json = true;
          return utils.doRequestWithOptions(opts, function(err, statusCode, result) {
            var update;
            try {
              if (err) {
                throw err;
              }
              response = result;
              // check display name already here
              update = false;
              update = (response['RepositoryVersions'].display_name === options.display_name) || true;
              index = index + 1;
              if ((index === items.length) || update) {
                return cb(null, update);
              } else {
                return do_check_current(index, items, cb);
              }
            } catch (error1) {
              err = error1;
              return cb(err);
            }
          });
        };
        return do_check_current(0, response.items, function(err, update) {
          var added, i, j, len, len1, os, os_config, ref, ref1, ref2;
          try {
            opts.json = false;
            opts.headers = utils.headers(options);
            if (err) {
              throw err;
            }
            opts.content = {
              RepositoryVersions: {
                repository_version: options.repository_version,
                display_name: options.display_name
              },
              operating_systems: []
            };
            //inspired from https://github.com/apache/ambari/blob/trunk/ambari-server/docs/api/v1/repository-version-resources.md
            // TODO repository base url validation
            added = false;
            ref = options.repositories;
            for (i = 0, len = ref.length; i < len; i++) {
              os_config = ref[i];
              if ((ref1 = os_config.os_type) !== 'redhat6' && ref1 !== 'redhat7' && ref1 !== 'centos6' && ref1 !== 'centos7') {
                throw Error('Os type not supported');
              }
              if (opts.content.operating_systems.length > 0) {
                ref2 = opts.content.operating_systems;
                for (j = 0, len1 = ref2.length; j < len1; j++) {
                  os = ref2[j];
                  if (os.OperatingSystems.os_type === os_config.os_type) {
                    os.repositories.push({
                      Repositories: {
                        repo_id: os_config.repo_id,
                        repo_name: os_config.repo_name,
                        base_url: os_config.base_url
                      }
                    });
                    added = true;
                  }
                  if (!added) { //os type not added yet
                    opts.content.operating_systems.push({
                      OperatingSystems: {
                        os_type: os_config.os_type
                      },
                      repositories: [
                        {
                          Repositories: {
                            repo_id: os_config.repo_id,
                            repo_name: os_config.repo_name,
                            base_url: os_config.base_url
                          }
                        }
                      ]
                    });
                  }
                }
              } else {
                opts.content.operating_systems.push({
                  OperatingSystems: {
                    os_type: os_config.os_type
                  },
                  repositories: [
                    {
                      Repositories: {
                        repo_id: os_config.repo_id,
                        repo_name: os_config.repo_name,
                        base_url: os_config.base_url
                      }
                    }
                  ]
                });
              }
            }
            // already_exist = false
            // for repository in response.items
            //   if (repository.stack_name is options.stack_name) and (repository.stack_version is options.stack_version)
            //     already_exist = true
            //     href = item.href
            //     break;
            // return do_end() if already_exist
            opts['method'] = update ? 'PUT' : 'POST';
            opts.content = JSON.stringify(opts.content);
            return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
              var ref3;
              try {
                if (err) {
                  throw err;
                }
                if (response !== '') {
                  response = JSON.parse(response);
                }
                if ((ref3 = parseInt(statusCode)) !== 200 && ref3 !== 201) {
                  throw Error(response.message);
                }
                status = true;
                return do_end();
              } catch (error1) {
                err = error1;
                error = err;
                return do_end();
              }
            });
          } catch (error1) {
            err = error1;
            error = err;
            console.log('catched', err);
            return do_end();
          }
        });
      } catch (error1) {
        err = error1;
        error = err;
        console.log('catched', err);
        return do_end();
      }
    });
  } catch (error1) {
    err = error1;
    error = err;
    return do_end();
  }
};

// ## Depencendies
utils = require('../utils');

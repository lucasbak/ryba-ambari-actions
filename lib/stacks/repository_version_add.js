// Generated by CoffeeScript 2.3.2
(function() {
  // # Ambari repository version add

  // Add a repository version for given stack [REST API v2](https://github.com/apache/ambari/blob/trunk/ambari-server/docs/api/v1)
  // The stack should exist as the target version

  // * `password` (string)
  //   Ambari Administrator password.
  // * `url` (string)   
  //   Ambari External URL.
  // * `username` (string)
  //   Ambari Administrator username.
  // * `cluster_name` (string)   
  //   Name of the cluster, optional
  // * `stack_name` (string)   
  //   name of the stack, required.
  // * `stack_version` (string)   
  //   version of the stack, required.  
  // * `stack_name` (string)   
  //   name of the stack, required.
  // * `repository_version` (string)   
  //   Fulle version of the target repository, required.  
  // * `display_name` (string)   
  //   display strong for the full version, required.  
  // * `repositories` (object)
  //     an object representing the repositories.
  //     the key should be the operating system
  //     the value should be an object containing all os' related repositories

  // ## Exemple

  // ```js
  // nikita
  // .stacks.repository_version_add({
  //   "username": 'ambari_admin',
  //   "password": 'ambari_secret',
  //   "url": "http://ambari.server.com",
  //   "cluster_name": 'my_cluster'
  //   "name": 'HDFS'
  //   }
  // }, function(err, status){
  //   console.log( err ? err.message : "Node Added To Cluster: " + status)
  // })
  // ```

  // ## Source Code
  var utils;

  module.exports = function(options, callback) {
    var do_end, err, error, hostname, opts, path, port, status;
    error = null;
    status = false;
    if (options.debug == null) {
      options.debug = false;
    }
    do_end = function() {
      if (callback != null) {
        return callback(error, status);
      }
      return new Promise(function(fullfil, reject) {
        if (error != null) {
          reject(error);
        }
        return fullfil(status);
      });
    };
    try {
      if (!options.username) {
        throw Error('Required Options: username');
      }
      if (!options.password) {
        throw Error('Required Options: password');
      }
      if (!options.url) {
        throw Error('Required Options: url');
      }
      if (!options.stack_name) {
        throw Error('Required Options: stack_name');
      }
      if (!options.stack_version) {
        throw Error('Required Options: stack_version');
      }
      if (!options.display_name) {
        throw Error('Required Options: display_name');
      }
      if (!options.repository_version) {
        throw Error('Required Options: repository_version');
      }
      if (!options.cluster_name) {
        throw Error('Required Options: cluster_name');
      }
      if (!options.repositories) {
        throw Error('Required Options: repositories');
      }
      [hostname, port] = options.url.split("://")[1].split(':');
      if (options.sslEnabled == null) {
        options.sslEnabled = options.url.split('://')[0] === 'https';
      }
      path = `/api/v1/stacks/${options.stack_name}/versions/${options.stack_version}/repository_versions/`;
      opts = {
        hostname: hostname,
        port: port,
        rejectUnauthorized: false,
        headers: utils.headers(options),
        sslEnabled: options.sslEnabled
      };
      opts['method'] = 'GET';
      opts.path = `${path}`;
      return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
        var do_check_current;
        try {
          if (err) {
            throw err;
          }
          response = JSON.parse(response);
          if (parseInt(statusCode) !== 200) {
            throw Error(response.message);
          }
          //if the display name already exist, we consider its an update set metho to PUT
          do_check_current = function(index, items, cb) {
            var item;
            if (items.length === 0) {
              return cb(null, false);
            }
            item = items[index];
            opts['method'] = 'GET';
            opts.path = item.href;
            opts.json = true;
            return utils.doRequestWithOptions(opts, function(err, statusCode, result) {
              var update;
              try {
                if (err) {
                  throw err;
                }
                response = result;
                // check display name already here
                update = false;
                update = (response['RepositoryVersions'].display_name === options.display_name) || true;
                index = index + 1;
                if ((index === items.length) || update) {
                  return cb(null, update);
                } else {
                  return do_check_current(index, items, cb);
                }
              } catch (error1) {
                err = error1;
                return cb(err);
              }
            });
          };
          return do_check_current(0, response.items, function(err, update) {
            var added, i, j, len, len1, os, os_config, ref, ref1, ref2;
            try {
              opts.json = false;
              opts.headers = utils.headers(options);
              if (err) {
                throw err;
              }
              opts.content = {
                RepositoryVersions: {
                  repository_version: options.repository_version,
                  display_name: options.display_name
                },
                operating_systems: []
              };
              //inspired from https://github.com/apache/ambari/blob/trunk/ambari-server/docs/api/v1/repository-version-resources.md
              // TODO repository base url validation
              added = false;
              ref = options.repositories;
              for (i = 0, len = ref.length; i < len; i++) {
                os_config = ref[i];
                if ((ref1 = os_config.os_type) !== 'redhat6' && ref1 !== 'redhat7' && ref1 !== 'centos6' && ref1 !== 'centos7') {
                  throw Error('Os type not supported');
                }
                if (opts.content.operating_systems.length > 0) {
                  ref2 = opts.content.operating_systems;
                  for (j = 0, len1 = ref2.length; j < len1; j++) {
                    os = ref2[j];
                    if (os.OperatingSystems.os_type === os_config.os_type) {
                      os.repositories.push({
                        Repositories: {
                          repo_id: os_config.repo_id,
                          repo_name: os_config.repo_name,
                          base_url: os_config.base_url
                        }
                      });
                      added = true;
                    }
                    if (!added) { //os type not added yet
                      opts.content.operating_systems.push({
                        OperatingSystems: {
                          os_type: os_config.os_type
                        },
                        repositories: [
                          {
                            Repositories: {
                              repo_id: os_config.repo_id,
                              repo_name: os_config.repo_name,
                              base_url: os_config.base_url
                            }
                          }
                        ]
                      });
                    }
                  }
                } else {
                  opts.content.operating_systems.push({
                    OperatingSystems: {
                      os_type: os_config.os_type
                    },
                    repositories: [
                      {
                        Repositories: {
                          repo_id: os_config.repo_id,
                          repo_name: os_config.repo_name,
                          base_url: os_config.base_url
                        }
                      }
                    ]
                  });
                }
              }
              // already_exist = false
              // for repository in response.items
              //   if (repository.stack_name is options.stack_name) and (repository.stack_version is options.stack_version)
              //     already_exist = true
              //     href = item.href
              //     break;
              // return do_end() if already_exist
              opts['method'] = update ? 'PUT' : 'POST';
              opts.content = JSON.stringify(opts.content);
              return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
                var ref3;
                try {
                  if (err) {
                    throw err;
                  }
                  if (response !== '') {
                    response = JSON.parse(response);
                  }
                  if ((ref3 = parseInt(statusCode)) !== 200 && ref3 !== 201) {
                    throw Error(response.message);
                  }
                  status = true;
                  return do_end();
                } catch (error1) {
                  err = error1;
                  error = err;
                  return do_end();
                }
              });
            } catch (error1) {
              err = error1;
              error = err;
              console.log('catched', err);
              return do_end();
            }
          });
        } catch (error1) {
          err = error1;
          error = err;
          console.log('catched', err);
          return do_end();
        }
      });
    } catch (error1) {
      err = error1;
      error = err;
      return do_end();
    }
  };

  // ## Depencendies
  utils = require('../utils');

}).call(this);

// Generated by CoffeeScript 2.3.2
(function() {
  // 'use strict'
  var http, https;

  module.exports = {
    headers: function(options) {
      var headers;
      headers = {
        'X-Requested-By': 'ambari',
        "cache-control": "no-cache"
      };
      if (options.username && options.password) {
        if (headers['Authorization'] == null) {
          headers['Authorization'] = 'Basic ' + new Buffer(options.username + ':' + options.password).toString('base64');
        }
      }
      return headers;
    },
    doRequestWithOptions: function(options, callback) {
      var do_end, do_request, error, ref, response, statusCode;
      if (typeof options.options === 'object') {
        options = options.options;
      }
      error = null;
      statusCode = null;
      response = null;
      if (options.hostname == null) {
        error = Error('Missin hostname');
      }
      if (options.port == null) {
        error = Error('Missing port');
      }
      if (options.method == null) {
        error = Error('Missing method');
      }
      if ((ref = options.method) !== 'GET' && ref !== 'POST' && ref !== 'PUT' && ref !== 'DELETE') {
        error = Error('Invalid method');
      }
      if (options.path == null) {
        error = Error('Mssing path');
      }
      do_end = function() {
        if (callback != null) {
          return callback(error, statusCode, response);
        }
        return new Promise(function(fullfil, reject) {
          if (error != null) {
            reject(error);
          }
          return fullfil(statusCode, response);
        });
      };
      do_request = function() {
        var base, base1, err, http_maker, opts, request, response_object;
        try {
          opts = {
            hostname: options.hostname,
            port: options.port,
            path: `${options.path}`,
            method: options.method,
            headers: options.headers
          };
          response_object = '';
          //ssl
          if (options.sslEnabled) {
            opts['rejectUnauthorized'] = options.rejectUnauthorized;
          }
          //headers
          if (opts.headers == null) {
            opts.headers = {};
          }
          if (options.json) {
            if ((base = opts.headers)['Content-Type'] == null) {
              base['Content-Type'] = 'application/json';
            }
          }
          if (options.content != null) {
            if (typeof options.content === 'string') {
              if ((base1 = opts.headers)['Content-Length'] == null) {
                base1['Content-Length'] = options.content.length;
              }
            }
          }
          http_maker = options.sslEnabled ? https : http;
          request = http_maker.request(opts, function(res) {
            res.on('data', function(data) {
              return response_object += data;
            });
            res.on('end', function() {
              var err;
              try {
                if (options.json) {
                  response_object = JSON.parse(response_object);
                }
                error = null;
                // if res.statusCode not in [200,201]
                //   response_object = JSON.parse response_object
                //   error = Error "Error: #{response_object.message}"
                statusCode = res.statusCode;
                response = response_object;
                return do_end();
              } catch (error1) {
                err = error1;
                error = err;
                return do_end();
              }
            });
            return res.on('error', function(err) {
              error = err;
              return do_end();
            });
          });
          if (options.content != null) {
            request.on('error', function(err) {
              error = err;
              if (err.errno === 'EHOSTUNREACH') {
                error = Error(`The server ${options.hostname}:${options.port} is not available`);
              }
              return do_end();
            });
            request.write(options.content);
            return request.end();
          } else {
            request.on('error', function(err) {
              error = err;
              if (err.errno === 'EHOSTUNREACH') {
                error = Error(`The server ${options.hostname}:${options.port} is not available`);
              }
              return do_end();
            });
            return request.end();
          }
        } catch (error1) {
          err = error1;
          error = err;
          return do_end();
        }
      };
      return do_request();
    }
  };

  // ## Dependencies
  http = require('http');

  https = require('https');

}).call(this);
